var documenterSearchIndex = {"docs":
[{"location":"neighborhoods/#Neighborhoods,-structuring-elements,-and-kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"In LocalFilters, at each index i of a source array A, a local filter involves the values A[i-k] of A for all indices k in the neighborhood B which is part of the filter.  For some neighborhoods, only the support of B (that is the range of valid indices k) is relevant, for others the values B[k] may also be considered.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Support-only neighborhoods can be hyperrectangular Cartesian regions represented by a RectangularBox instance or regions with more complex shapes which are represented by (usually) small arrays with offset axes and boolean entries (true where entries are part of the neighborhood).  Such neighborhoods are used to define the so-called structuring element of mathematical morphology non-linear filters (see Section Non-linear morphological filters).","category":"page"},{"location":"neighborhoods/#Neighborhoods-and-structuring-elements","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods and structuring elements","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Neighborhood is the abstract type of which all neighborhood types inherit.  The most simple neighborhood is a hyperrectangular Cartesian region constructed by:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"RectangularBox(start, stop)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where start and stop are Cartesian indices (instances of CartesianIndex{N}) respectively specifying the first and last indices of the region.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Another possibility is to specify the dimensions of the box and the offsets of its central element:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"RectangularBox(dims, offs)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"with dims a N-tuple of dimensions and offs either a N-tuple of indices of an instance of CartesianIndex{N}.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"A RectangularBox can also be defined by the index ranges along all the dimensions.  For example:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"RectangularBox(-3:3, 0, -2:1)\nRectangularBox((-3:3, 0, -2:1))","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"both yield a 3-dimensional RectangularBox of size 7×1×4 and whose first index varies on -3:3, its second index is 0 while its third index varies on -2:1.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"Finally, a RectangularBox can be defined as:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"RectangularBox(R)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where R is an instance of CartesianIndices.","category":"page"},{"location":"neighborhoods/#Kernels","page":"Neighborhoods, structuring elements, and kernels","title":"Kernels","text":"","category":"section"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"A LocalFilters.Kernel can be used to define a weighted neighborhood (for weighted local average or for convolution) or a structuring element (for mathematical morphology).  It is a rectangular array of coefficients over a, possibly off-centered, rectangular neighborhood.  In general, it is sufficient to specify ::LocalFilters.Kernel{T,N} in the signature of methods, with T the type of the coefficients and N the number of dimensions (the third parameter A of the type is to fully qualify the type of the array of coefficients).","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"A kernel is built as:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"B = LocalFilters.Kernel{T}(C, start=default_start(C))","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where C is the array of coefficients (which can be retrieved by coefs(B)) and start the initial CartesianIndex for indexing the kernel (which can be retrieved by first_cartesian_index(B)).  The start parameter let the caller choose an arbitrary origin for the kernel coefficients; when a filter is applied, the following mapping is assumed:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"B[k] ≡ C[k + off]","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where off = first_cartesian_index(C) - first_cartesian_index(B).","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"If start is omitted, its value is set so that the origin (whose index is zero(CartesianIndex{N}) with N the number of dimensions) of the kernel indices is at the geometric center of the array of coefficients (see LocalFilters.default_start).  Optional type parameter T is to impose the type of the coefficients.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"To convert the element type of the coefficients of an existing kernel, do:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"LocalFilters.Kernel{T}(K)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"which yields a kernel whose coefficients are those of the kernel K converted to type T.","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"It is also possible to convert instances of RectangularBox into a kernel with boolean coefficients by calling:","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"LocalFilters.Kernel(B)","category":"page"},{"location":"neighborhoods/","page":"Neighborhoods, structuring elements, and kernels","title":"Neighborhoods, structuring elements, and kernels","text":"where B is the neighborhood to convert into an instance of Kernel.","category":"page"},{"location":"separable/#Efficient-separable-filters-for-associative-operations","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"","category":"section"},{"location":"separable/#Out-of-place-version","page":"Efficient separable filters for associative operations","title":"Out-of-place version","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The localfilter method may be called as:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"dst = localfilter([T=eltype(A),] A, dims, op, rngs [, w])","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"to apply the van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs.  Optional argument T is the element type of the result dst (by default T = eltype(A)). Optional argument w is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as A which is resized as needed (by calling the resize! method).","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Argument dims specifies along which dimension(s) of A the filter is to be applied, it can be a single integer, several integers or a colon : to specify all dimensions.  Dimensions are processed in the order given by dims (the same dimension may appear several times) and there must be a matching interval in rngs to specify the structuring element (except that if rngs is a single interval, it is used for every dimension in dims).  An interval is either an integer or an integer valued unit range in the form kmin:kmax (an interval specified as a single integer, say k, is the same as specifying k:k).","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Assuming a mono-dimensional array A, the single filtering pass:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(dst, A, :, op, rng)","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"yields:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"dst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"for all j ∈ [first(axes(A,1)):last(axes(A,1))], with x ⋄ y = op(x, y), kmin = first(rng) and kmax = last(rng).  Note that if kmin = kmax = k (which occurs if rng is a simple integer), the result of the filter is to operate a simple shift by k along the corresponding dimension and has no effects if k = 0.  This can be exploited to not filter some dimension(s).","category":"page"},{"location":"separable/#In-place-version","page":"Efficient separable filters for associative operations","title":"In-place version","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The localfilter! method implement the in-place version of the van Herk-Gil-Werman algorithm:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!([dst = A,] A, dims, op, rngs [, w]) -> dst","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"overwrites the contents of dst with the result of the filter and returns dst.  The destination array dst must have the same indices as the source A (that is, axes(dst) == axes(A)).  If dst is not specified or if dst is A, the operation is performed in-place.","category":"page"},{"location":"separable/#Examples","page":"Efficient separable filters for associative operations","title":"Examples","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The in-place morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be applied by:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, :, min, -3:3)","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Index interval 0 may be specified to do nothing along the corresponding dimension.  For instance, assuming A is a three-dimensional array:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, :, max, (-3:3, 0, -4:4))","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"overwrites A by its morphological dilation (i.e. local maximum) in a centered local neighborhood of size 7×1×9 (nothing is done along the second dimension).  The same result may be obtained with:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter!(A, (1,3), max, (-3:3, -4:4))","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"where the second dimension is omitted from the list of dimensions.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The local average of the two-dimensional array A on a centered moving window of size 11×11 can be computed as:","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"localfilter(A, :, +, (-5:5, -5:5))*(1/11)","category":"page"},{"location":"separable/#Efficiency-and-restrictions","page":"Efficient separable filters for associative operations","title":"Efficiency and restrictions","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"The van Herk-Gil-Werman algorithm is very fast for rectangular structuring elements.  It takes at most 3 operations to filter an element along a given dimension whatever the width p of the considered local neighborhood.  For N-dimensional arrays, the algorithm requires only 3N operations per element instead of p^N - 1 operations for a naive implementation.  This however requires to make a pass along each dimension so memory page faults may reduce the performances. This is somewhat attenuated by the fact that the algorithm can be applied in-place.  For efficient multi-dimensional out-of-place filtering, it is recommended to make the first pass with a fresh destination array and then all other passes in-place on the destination array.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"To apply the van Herk-Gil-Werman algorithm, the structuring element must be separable along the dimensions and its components must be contiguous.  In other words, the algorithm is only applicable for N-dimensional rectangular neighborhoods, so-called hyperrectangles.  The structuring element may however be off-centered by arbitrary offsets along each dimension.","category":"page"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"To take into account boundary conditions (for now, only nearest neighbor is implemented) and allow for in-place operation, the algorithm allocates a workspace array.","category":"page"},{"location":"separable/#References","page":"Efficient separable filters for associative operations","title":"References","text":"","category":"section"},{"location":"separable/","page":"Efficient separable filters for associative operations","title":"Efficient separable filters for associative operations","text":"Marcel van Herk, \"A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels\" in Pattern Recognition Letters 13, 517-521 (1992).\nJoseph Gil and Michael Werman, \"Computing 2-D Min, Median, and Max Filters\" in IEEE Transactions on Pattern Analysis and Machine Intelligence 15, 504-507 (1993).","category":"page"},{"location":"linear/#Linear-filters","page":"Linear filters","title":"Linear filters","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"LocalFilters provides a few linear filters: localmean or localmean! to compute the mean of values in a neighborhood, and convolve or convolve! to compute the discrete convolution of an array by a kernel.","category":"page"},{"location":"linear/#Local-mean","page":"Linear filters","title":"Local mean","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The localmean method yields the local mean of an array A in a neighborhood B:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"localmean(A, B=3) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The result dst is an array similar to A.  If B is not specified, the neighborhood is a hyperrectangular moving window of size 3 in every dimension. Otherwise, B may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as A.  If B is a single odd integer (as it is by default), the neighborhood is assumed to be a hyperrectangular moving window of size B in every dimension.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"To avoid allocations, use the in-place version localmean! and call:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"localmean!(dst, A, B=3) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to overwrite dst with the local mean of A in the neighborhood defined by B.","category":"page"},{"location":"linear/#Convolution","page":"Linear filters","title":"Convolution","text":"","category":"section"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"The convolve method yields the discrete convolution of an array by a kernel.  Its syntax is:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"convolve(A, B) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to yield the discrete convolution of array A by the kernel defined by B. The result dst is an array similar to A.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Using Sup(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete convolution of A by B writes:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = promote_type(eltype(A), eltype(B))\nfor i ∈ Sup(A)\n    v = zero(T)\n    @inbounds for k ∈ Sup(B) ∩ (i - Sup(A))\n        v += A[i-k]*B[k]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"with T the type of the product of elements of A and B, and where Sup(B) ∩ (i - Sup(A)) denotes the subset of indices k such that k ∈ Sup(B) and i - k ∈ Sup(A) and thus for which B[k] and A[i-k] are valid.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"Following the conventions in localfilter!, the discrete convolution can also be expressed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = promote_type(eltype(A), eltype(B))\nfor i ∈ Sup(A)\n    v = zero(T)\n    @inbounds for j ∈ Sup(A) ∩ (i - Sup(B))\n        v += A[j]*B[i-j]\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"If the kernel B is an array of booleans, the discrete convolution is computed as:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"T = eltype(A)\nfor i ∈ Sup(A)\n    v = zero(T)\n    for j ∈ Sup(A) ∩ (i - Sup(B))\n        if B[i-j]\n            v += A[j]\n        end\n    end\n    dst[i] = v\nend","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"which amounts to computing the local sum of the values of A in the neighborhood defined by the true entries of B.","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"To avoid allocations, use the in-place version convolve! and call:","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"convolve!(dst, A, B) -> dst","category":"page"},{"location":"linear/","page":"Linear filters","title":"Linear filters","text":"to overwrite dst with the discrete convolution of A by the kernel B.","category":"page"},{"location":"nonlinear/#Non-linear-filters","page":"Non-linear filters","title":"Non-linear filters","text":"","category":"section"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"LocalFilters provides a number of non-linear filters such as the bilateral filter and mathematical morphology filters.  The latter are described in the Mathematical morphology section.","category":"page"},{"location":"nonlinear/#The-bilateral-filter","page":"Non-linear filters","title":"The bilateral filter","text":"","category":"section"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"bilateralfilter([T=float(eltype(A)),] A, F, G, ...)","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"yields the result of applying the bilateral filter on array A.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Argument F specifies how to smooth the differences in values.  It may be function which takes two values from A as arguments and returns a nonnegative weight.  It may be a real which is assumed to be the standard deviation of a Gaussian.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Arguments G, ... specify the settings of the distance filter for smoothing differences in coordinates.  There are several possibilities:","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"G, ... can be a LocalFilters.Kernel instance (specified as a single argument).\nArgument G may be a function taking as argument the Cartesian index of the coordinate differences and returning a nonnegative weight.  Argument G may also be a real specifying the standard deviation of the Gaussian used to compute weights.  Subsequent arguments ... are to specify the neighborhood where to apply the distance filter function, they can be a Neighborhood object such as a RectangularBox or anything that may defined a neighborhood such as an odd integer assumed to be the width of the neighborhood along every dimensions of A.  If a standard deviation σ is specified for G with no subsequent arguments, a default window of radius 3σ is assumed.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"Optional argument T can be used to force the element type used for (most) computations.  This argument is needed if the element type of A is not a real.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See bilateralfilter! for an in-place version of this function.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"bilateralfilter!([T=float(eltype(A)),] dst, A, F, G, ...) -> dst","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"overwrites dst with the result of applying the bilateral filter on array A and returns dst.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See bilateralfilter for a description of the other arguments than dst.","category":"page"},{"location":"nonlinear/","page":"Non-linear filters","title":"Non-linear filters","text":"See wikipedia for a description of the bilateral filter.","category":"page"},{"location":"morphology/#Non-linear-morphological-filters","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"","category":"section"},{"location":"morphology/#Basic-morphological-operations","page":"Non-linear morphological filters","title":"Basic morphological operations","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Erosion and dilation are the basic operations of mathematical morphology, they are implemented by methods erode and dilate:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode(A, R=3) -> Amin\ndilate(A, R=3) -> Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"which respectively return the local minima Amin and the local maxima Amax of argument A in a structuring element defined by R.  The notion of structuring element in mathematical morphology is equlvalent to that of neighborhood in LocalFilters.  The returned result is similar to A (same size and type).  If R is not specified, a default hyperrectangular moving window of size 3 in every dimension of A is used.  If the structuring element R is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"The localextrema method combines these two operations in one call:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"localextrema(A, R=3) -> Amin, Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Calling localextrema is usually almost twice as fast as calling erode and dilate.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"To avoid allocating new arrays, the methods erode!, dilate!, and localextrema! provide in-place versions which apply the operation to A with structuring element R and store the result in the provided arrays Amin and/or Amax:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode!(Amin, A, R=3) -> Amin\ndilate!(Amax, A, R=3) -> Amax\nlocalextrema!(Amin, Amax, A, R=3) -> Amin, Amax","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"If the structuring element R is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place.  That is, A and Amin can be the same arrays.  In that case, the following syntax is allowed:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"erode!(A, R=3) -> A\ndilate!(A, R=3) -> A","category":"page"},{"location":"morphology/#Opening-and-closing-filters","page":"Non-linear morphological filters","title":"Opening and closing filters","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"closing(A, R=3)\nopening(A, R=3)","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"respectively perform a closing or an opening of array A by the structuring element R.  If R is not specified, a default hyperrectangular moving window of size 3 in every dimension of A is used.  A closing is a dilation followed by an erosion, whereas an opening is an erosion followed by a dilation.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"The in-place versions are:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"closing!(dst, wrk, A, R=3) -> dst\nopening!(dst, wrk, A, R=3) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"which perform the operation on the source A and store the result in destination dst using wrk as a workspace array.  The 3 arguments dst, wrk, and A must be similar arrays; dst and A may be identical, but wrk must not be the same array as A or dst.  The destination dst is returned.","category":"page"},{"location":"morphology/#Top-hat-and-bottom-hat-filters","page":"Non-linear morphological filters","title":"Top-hat and bottom-hat filters","text":"","category":"section"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Methods top_hat and bottom_hat perform a summit/valley detection by applying a top-hat filter to an array.  They are called as:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat(A, R[, S]) -> dst\nbottom_hat(A, R[, S]) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"to yield the result of the filter applied to array A.  Argument R defines the structuring element for the feature detection.  Optional argument S specifies the structuring element for smoothing A prior to the top-/bottom-hat filter.  If R and S are specified as the radii of the structuring elements, then S should be smaller than R.  For instance:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat(bitmap, 3, 1)","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"may be used to detect text or lines in a bitmap image.","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"Methods LocalFilters.top_hat! and LocalFilters.bottom_hat! implement the in-place versions of these filters:","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"top_hat!(dst, wrk, A, R[, S]) -> dst\nbottom_hat!(dst, wrk, A, R[, S]) -> dst","category":"page"},{"location":"morphology/","page":"Non-linear morphological filters","title":"Non-linear morphological filters","text":"apply the top-/bottom-hat filter on the source A and store the result in the destination dst using wrk as a workspace array.  The 3 arguments dst, wrk, and A must be similar but different arrays.  The destination dst is returned.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following summarizes the documentation of types and methods provided by the LocalFilters package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"reference/#Linear-filters","page":"Reference","title":"Linear filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"LocalFilters provides convolutive filters which are shift-invariant linear filters.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"localmean\nlocalmean!\nconvolve\nconvolve!","category":"page"},{"location":"reference/#LocalFilters.localmean","page":"Reference","title":"LocalFilters.localmean","text":"localmean(A, B=3)\n\nyields the local mean of A in a neighborhood defined by B.  The result is an array similar to A.  If B is not specified, the neighborhood is a hyperrectangular moving window of size 3 in every dimension.  Otherwise, B may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as A.  If B is a single odd integer (as it is by default), the neighborhood is assumed to be a hyperrectangular moving window of size B in every dimension.\n\nSee also localmean! and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localmean!","page":"Reference","title":"LocalFilters.localmean!","text":"localmean!(dst, A, B=3) -> dst\n\noverwrites dst with the local mean of A in a neighborhood defined by B and returns dst.\n\nSee also localmean and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.convolve","page":"Reference","title":"LocalFilters.convolve","text":"convolve(A, B)\n\nyields the discrete convolution of array A by the kernel defined by B.  The result dst is an array similar to A.\n\nUsing Sup(A) to denote the set of valid indices for array A and assuming B is an array of values, the discrete convolution of A by B writes:\n\nT = promote_type(eltype(A), eltype(B))\nfor i ∈ Sup(A)\n    v = zero(T)\n    @inbounds for k ∈ Sup(B) ∩ (i - Sup(A))\n        v += A[i-k]*B[k]\n    end\n    dst[i] = v\nend\n\nwith T the type of the product of elements of A and B, and where Sup(B) ∩ (i - Sup(A)) denotes the subset of indices k such that k ∈ Sup(B) and i - k ∈ Sup(A) and thus for which B[k] and A[i-k] are valid.\n\nSee also convolve! and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.convolve!","page":"Reference","title":"LocalFilters.convolve!","text":"convolve!(dst, A, B) -> dst\n\noverwrites dst with the discrete convolution of A by the kernel B and returns dst.\n\nSee also convolve and localfilter!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Mathematical-morphology","page":"Reference","title":"Mathematical morphology","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"erode\nerode!\ndilate\ndilate!\nlocalextrema\nlocalextrema!\nclosing\nclosing!\nopening\nopening!\ntop_hat\nLocalFilters.top_hat!\nbottom_hat\nLocalFilters.bottom_hat!\nstrel","category":"page"},{"location":"reference/#LocalFilters.erode","page":"Reference","title":"LocalFilters.erode","text":"erode(A, R=3) -> Amin\n\nyields the erosion of A by the structuring element defined by R.  The erosion is the array of local minima of A.  The returned result Amin is similar to A (same size and type).\n\nIf the structuring element R is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used.  If specified as an odd integer (as is assumed by default), the structuring element is a hyperrectangular moving window of size R along every dimension of A.\n\nAn erosion is one of the most basic operations of mathematical morphology.  See erode! for an in-place version of the method, dilate for retrieving the local maxima, and localextrema for performing an erosion and a dilation in a single pass.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.erode!","page":"Reference","title":"LocalFilters.erode!","text":"erode!(Amin, A, R=3) -> Amin\n\noverwrites Amin with the erosion of the array A by the structuring element defined by R and returns Amin.\n\nIf the structuring element R is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place.  That is, A and Amin can be the same arrays.  In that case, the following syntax is allowed:\n\nerode!(A, R=3) -> A\n\nSee erode for an out-of-place version and for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.dilate","page":"Reference","title":"LocalFilters.dilate","text":"dilate(A, R=3) -> Amax\n\nyields the dilation of A by the structuring element defined by R.  The dilation is the array of local maxima of A.  The returned result Amax is similar to A (same size and type).\n\nIf the structuring element R is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used.  If specified as an odd integer (as is assumed by default), the structuring element is a hyperrectangular moving window of size R along every dimension of A.\n\nA dilation is one of the most basic operations of mathematical morphology.  See dilate! for an in-place version of the method, erode for retrieving the local minima, and localextrema for performing an erosion and a dilation in a single pass.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.dilate!","page":"Reference","title":"LocalFilters.dilate!","text":"dilate!(Amax, A, R=3) -> Amax\n\noverwrites Amax with a dilation of the array A by the structuring element defined by R and returns Amax.\n\nIf the structuring element R is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place.  That is, A and Amin can be the same arrays.  In that case, the following syntax is allowed:\n\ndilate!(A, R=3) -> A\n\nSee dilate for an out-of-place version and for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localextrema","page":"Reference","title":"LocalFilters.localextrema","text":"localextrema(A, R=3) -> Amin, Amax\n\nyields the results of performing an erosion and a dilation of A by the structuring element defined by R in a single pass.  Calling this method is usually almost twice as fast as calling erode and dilate.\n\nSee localextrema! for an in-place version of the method, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localextrema!","page":"Reference","title":"LocalFilters.localextrema!","text":"localextrema!(Amin, Amax, A, R=3) -> Amin, Amax\n\noverwrites Amin and Amax with, respectively, an erosion and a dilation of the array A by the structuring element defined by R in a single pass.\n\nSee localextrema for an out-of-place version for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.closing","page":"Reference","title":"LocalFilters.closing","text":"closing(A, R=3) -> dst\n\nyields a closing of array A by the structuring element defined by R.  A closing is a dilation followed by an erosion.  The result dst is an array similar to A.\n\nSee closing! for an in-place version of the method, opening for a related filter, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.closing!","page":"Reference","title":"LocalFilters.closing!","text":"closing!(dst, wrk, A, R=3) -> dst\n\noverwrites dst with the result of a closing of A by the structuring element defined by R using wrk as a workspace array.  The arguments dst, wrk, and A must be similar arrays, dst and A may be identical, but wrk must not be the same array as A or dst.  The destination dst is returned.\n\nSee closing for a description of this kind of filter and for the meaning of the arguments.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.opening","page":"Reference","title":"LocalFilters.opening","text":"opening(A, R=3) -> dst\n\nyields an opening of array A by the structuring element defined by R.  An opening is an erosion followed by a dilation.  The result dst is an array similar to A.\n\nSee opening! for an in-place version of the method, closing for a related filter, and erode or dilate for a description of these operations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.opening!","page":"Reference","title":"LocalFilters.opening!","text":"opening!(dst, wrk, A, R=3) -> dst\n\noverwrites dst with the result of an opening of A by the structuring element defined by R using wrk as a workspace array.  The arguments dst, wrk, and A must be similar arrays, dst and A may be identical, but wrk must not be the same array as A or dst.  The destination dst is returned.\n\nSee opening for a description of this kind of filter and for the meaning of the arguments.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.top_hat","page":"Reference","title":"LocalFilters.top_hat","text":"top_hat(A, R=3 [, S]) -> dst\n\nperforms a summit detection by applying a top-hat filter to array A using the structuring element defined by R for the feature detection.  Top-hat filtering is equivalent to:\n\ndst = A .- opening(A, R)\n\nOptional argument S specifies the structuring element for smoothing A prior to top-hat filtering.  If R and S are specified as the radii of the structuring elements, then S should be smaller than R.  For instance:\n\ntop_hat(bitmap, 3, 1)\n\nmay be used to detect text or lines in a bitmap image.\n\nSee bottom_hat for a related operation, LocalFilters.top_hat! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.top_hat!","page":"Reference","title":"LocalFilters.top_hat!","text":"LocalFilters.top_hat!(dst, wrk, A, R=3) -> dst\n\noverwrites dst with the result of a top-hat filter applied to A with structuring element R, and using wrk as a workspace whose contents is not preserved.  The arguments A, dst, and wrk must be similar but different arrays.  The destination dst is returned.\n\nSee also top_hat for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bottom_hat","page":"Reference","title":"LocalFilters.bottom_hat","text":"bottom_hat(A, R=3 [, S]) -> dst\n\nperforms a valley detection by applying a bottom-hat filter to array A using the structuring element defined by R for the feature detection. Bottom-hat filtering is equivalent to:\n\ndst = closing(A, R) .- A\n\nOptional argument S specifies the structuring element for smoothing A prior to bottom-hat filtering.  If R and S are specified as the radii of the structuring elements, then S should be smaller than R.\n\nSee top_hat for a related operation, LocalFilters.bottom_hat! for an in-place version.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.bottom_hat!","page":"Reference","title":"LocalFilters.bottom_hat!","text":"LocalFilters.bottom_hat!(dst, wrk, A, R=3) -> dst\n\noverwrites dst with the result of a bottom-hat filter applied to A with structuring element R and optional smoothing element S.  Argument wrk is a workspace array whose contents is not preserved.  The arguments A, dst, and wrk must be similar but different arrays.  The destination dst is returned.\n\nSee also bottom_hat for more details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.strel","page":"Reference","title":"LocalFilters.strel","text":"strel(T, A)\n\nyields a structuring element suitable for mathematical morphology operations. The result is a Kernel whose elements have type T (which can be Bool or a floating-point type).  Argument A can be a Cartesian box or a Kernel with boolean elements.\n\nIf T is a floating-point type, then the result is a so-called flat structuring element whose coefficients are zero(T) inside the shape defined by A and -T(Inf) elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Other-non-linear-filters","page":"Reference","title":"Other non-linear filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"bilateralfilter\nbilateralfilter!","category":"page"},{"location":"reference/#LocalFilters.BilateralFilter.bilateralfilter","page":"Reference","title":"LocalFilters.BilateralFilter.bilateralfilter","text":"bilateralfilter([T=float(eltype(A)),] A, F, G, ...)\n\nyields the result of applying the bilateral filter on array A.\n\nArgument F specifies how to smooth the differences in values.  It may be function which takes two values from A as arguments and returns a nonnegative weight.  It may be a real which is assumed to be the standard deviation of a Gaussian.\n\nArguments G, ... specify the settings of the distance filter for smoothing differences in coordinates.  There are several possibilities:\n\nG, ... can be a LocalFilters.Kernel instance (specified as a single argument).\nArgument G may be a function taking as argument the Cartesian index of the coordinate differences and returning a nonnegative weight.  Argument G may also be a real specifying the standard deviation of the Gaussian used to compute weights.  Subsequent arguments ... are to specify the neighborhood where to apply the distance filter function, they can be a Neighborhood object such as a RectangularBox or anything that may defined a neighborhood such as an odd integer assumed to be the width of the neighborhood along every dimensions of A.  If a standard deviation σ is specified for G with no subsequent arguments, a default window of size ±3σ is assumed.\n\nOptional argument T can be used to force the element type used for (most) computations.  This argument is needed if the element type of A is not a real.\n\nSee bilateralfilter! for an in-place version of this function and see Wikipedia for a description of the bilateral filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.BilateralFilter.bilateralfilter!","page":"Reference","title":"LocalFilters.BilateralFilter.bilateralfilter!","text":"bilateralfilter!([T=float(eltype(A)),] dst, A, F, G, ...) -> dst\n\noverwrites dst with the result of applying the bilateral filter on array A and returns dst.\n\nSee bilateralfilter for a description of the other arguments than dst and see Wikipedia for a description of the bilateral filter.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Generic-driver-for-custom-local-filters","page":"Reference","title":"Generic driver for custom local filters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"localfilter\nlocalfilter!","category":"page"},{"location":"reference/#LocalFilters.localfilter","page":"Reference","title":"LocalFilters.localfilter","text":"localfilter([T=eltype(A),] A, dims, op, rngs[, wrk]) -> dst\n\nyields the result of applying van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs.  Optional argument wrk is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as A and it is resized as needed (by calling the resize! method).  The optional argument T allows to specify another type of element than eltype(A) for the result.\n\nArgument dims specifies along which dimension(s) of A the filter is to be applied, it can be a single integer, a tuple of integers, or a colon : to apply the operation to all dimensions.  Dimensions are processed in the order given by dims (the same dimension may appear several times) and there must be a matching interval in rngs to specify the structuring element (except that if rngs is a single interval, it is used for every dimension in dims).  An interval is either an integer or an integer valued unit range in the form kmin:kmax (an interval specified as a single integer, say k, is the same as specifying k:k).\n\nAssuming a mono-dimensional array A, the single filtering pass:\n\nlocalfilter(A, :, op, rng)\n\namount to computing:\n\ndst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]\n\nfor all j ∈ [first(axes(A,1)):last(axes(A,1))], with x ⋄ y = op(x, y), kmin = first(rng) and kmax = last(rng).  Note that if kmin = kmax = k (which occurs if rng is a simple integer), the result of the filter is to operate a simple shift by k along the corresponding dimension and has no effects if k = 0.  This can be exploited to not filter some dimension(s).\n\nSee localfilter! for an in-place version of the method.\n\nExamples\n\nThe in-place morphological erosion (local minimum) of the array A on a centered structuring element of width 7 in every dimension can be applied by:\n\nlocalfilter!(A, :, min, -3:3)\n\nIndex interval 0 may be specified to do nothing along the corresponding dimension.  For instance, assuming A is a three-dimensional array:\n\nlocalfilter!(A, :, max, (-3:3, 0, -4:4))\n\noverwrites A by its morphological dilation (i.e. local maximum) in a centered local neighborhood of size 7×1×9 (nothing is done along the second dimension).  The same result may be obtained with:\n\nlocalfilter!(A, (1,3), max, (-3:3, -4:4))\n\nwhere the second dimension is omitted from the list of dimensions.\n\nThe local average of the two-dimensional array A on a centered moving window of size 11×11 can be computed as:\n\nlocalfilter(A, :, +, (-5:5, -5:5))*(1/11)\n\nEfficiency and restrictions\n\nThe van Herk-Gil-Werman algorithm is very fast for rectangular structuring elements.  It takes at most 3 operations to filter an element along a given dimension whatever the width p of the considered local neighborhood.  For N-dimensional arrays, the algorithm requires only 3N operations per element instead of p^N - 1 operations for a naive implementation.  This however requires to make a pass along each dimension so memory page faults may reduce the performances.  This is somewhat attenuated by the fact that the algorithm can be applied in-place.  For efficient multi-dimensional out-of-place filtering, it is recommended to make the first pass with a fresh destination array and then all other passes in-place on the destination array.\n\nTo apply the van Herk-Gil-Werman algorithm, the structuring element must be separable along the dimensions and its components must be contiguous.  In other words, the algorithm is only applicable for N-dimensional rectangular neighborhoods, so-called hyperrectangles.  The structuring element may however be off-centered by arbitrary offsets along each dimension.\n\nTo take into account boundary conditions (for now, only nearest neighbor is implemented) and allow for in-place operation, the algorithm allocates a workspace array.\n\nReferences\n\nMarcel van Herk, \"A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels\" in Pattern Recognition Letters 13, 517-521 (1992).\nJoseph Gil and Michael Werman, \"Computing 2-D Min, Median, and Max Filters\" in IEEE Transactions on Pattern Analysis and Machine Intelligence 15, 504-507 (1993).\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.localfilter!","page":"Reference","title":"LocalFilters.localfilter!","text":"localfilter!([dst = A,] A, dims, op, rngs[, wrk])\n\noverwrites the contents of dst with the result of applying van Herk-Gil-Werman algorithm to filter array A along dimension(s) dims with (associative) binary operation op and contiguous structuring element(s) defined by the interval(s) rngs and using optional argument wrk as a workspace array.  The destination dst must have the same indices as the source A (that is, axes(dst) == axes(A)).  Operation may be done in-place and dst and A can be the same; this is the default behavior if dst is not specified.\n\nSee localfilter for a full description of the method.\n\n\n\n\n\nlocalfilter!(dst, A, B, initial, update, store!) -> dst\n\noverwrites the destination dst with the result of a local filter applied to the source A, on a relative neighborhood defined by B, and implemented by the functions initial, update, and store!.  The purpose of these functions is explained by the following pseudo-code implementing the local fitering:\n\n@inbounds for i ∈ Sup(A)\n    v = initial(A[i])\n    for j ∈ Sup(A) ∩ (i - Sup(B))\n        v = update(v, A[j], B[i-j])\n    end\n    store!(dst, i, v)\nend\n\nwhere Sup(A) denotes the support of A (that is the set of indices in A) and i - Sup(B) denotes the set of indices j such that i - j ∈ Sup(B) with Sup(B) the support of B.  In other words, j ∈ Sup(A) ∩ (i - Sup(B)) means all indices j such that j ∈ Sup(A) and i - j ∈ Sup(B) so that A[j] and B[i-j] are in-bounds.\n\nwarning: Warning\nThe loop(s) in localfilter! are performed without bounds checking of the destination and it is the caller's responsibility to insure that the destination have the correct size.  It is however always possible to write store! so that it performs bounds checking.\n\nFor example, implementing a local minimum filter (that is, an erosion), is as simple as:\n\nlocalfilter!(dst, A, B,\n             (a)     -> typemax(a),\n             (v,a,b) -> min(v,a),\n             (d,i,v) -> @inbounds(d[i] = v))\n\nAs another example, implementing a convolution by B writes:\n\nlocalfilter!(dst, A, B,\n             (a)     -> zero(a),\n             (v,a,b) -> v + a*b,\n             (d,i,v) -> @inbounds(d[i] = v))\n\nnote: Note\nIf the methods init, update, and/or store! are anonymous functions or closures, beware that they should not depend on local variables because this may have a strong impact on performances.  For instance, you may consider using LocalFilters.ConstantProducer as a replacement for init (have a look at the implementation of methods such as localmean! or convolve!).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Neighborhood\nRectangularBox\nLocalFilters.Kernel\nLocalFilters.ConstantProducer","category":"page"},{"location":"reference/#LocalFilters.Neighborhood","page":"Reference","title":"LocalFilters.Neighborhood","text":"Neighborhood\n\nis the abstract type of which all neighborhood types inherit.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.RectangularBox","page":"Reference","title":"LocalFilters.RectangularBox","text":"RectangularBox(start, stop)\n\nyields a neighborhood which is a rectangular (Cartesian) box defined by the bounds of the multi-dimensional indices in the box.\n\nAnother possibility is to specify the dimensions of the box and the offsets of its central element:\n\nRectangularBox(dims, offs)\n\nwith dims a N-tuple of dimensions and offs either a N-tuple of indices of an instance of CartesianIndex{N}.\n\nA RectangularBox can also be defined by the index ranges along all the dimensions.  For example:\n\nRectangularBox(-3:3, 0, -2:1)\nRectangularBox((-3:3, 0, -2:1))\n\nboth yield a 3-dimensional RectangularBox of size 7×1×4 and whose first index varies on -3:3, its second index is 0 while its third index varies on -2:1.\n\nFinally, a RectangularBox can be defined as:\n\nRectangularBox(R)\n\nwhere R is an instance of CartesianIndices.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.Kernel","page":"Reference","title":"LocalFilters.Kernel","text":"A Kernel can be used to define a weighted neighborhood (for weighted local average or for convolution) or a structuring element (for mathematical morphology).  It is a rectangular array of coefficients over a, possibly off-centered, rectangular neighborhood.  In general, it is sufficient to specify ::Kernel{T,N} in the signature of methods, with T the type of the coefficients and N the number of dimensions (the third parameter A of the type is to fully qualify the type of the array of coefficients).\n\nA kernel is built as:\n\nB = Kernel{T}(C, start=default_start(C))\n\nwhere C is the array of coefficients (which can be retrieved by coefs(B)) and start the initial CartesianIndex for indexing the kernel (which can be retrieved by first_cartesian_index(B)).  The start parameter let the caller choose an arbitrary origin for the kernel coefficients; when a filter is applied, the following mapping is assumed:\n\nB[k] ≡ C[k + off]\n\nwhere off = first_cartesian_index(C) - first_cartesian_index(B).\n\nIf start is omitted, its value is set so that the origin (whose index is zero(CartesianIndex{N}) with N the number of dimensions) of the kernel indices is at the geometric center of the array of coefficients (see LocalFilters.default_start).  Optional type parameter T is to impose the type of the coefficients.\n\nTo convert the element type of the coefficients of an existing kernel, do:\n\nKernel{T}(K)\n\nwhich yields a kernel whose coefficients are those of the kernel K converted to type T.\n\nIt is also possible to convert instances of RectangularBox into a kernel with boolean coefficients by calling:\n\nKernel(B)\n\nwhere B is the neighborhood to convert into an instance of Kernel.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalFilters.ConstantProducer","page":"Reference","title":"LocalFilters.ConstantProducer","text":"ConstantProducer(val)\n\nyields a functor object which, when called as a function with any number of arguments of any types, always yields the value val.\n\nThis is useful to avoid closures which are quite inefficient and thus have a strong impact on performances when called repeatedly in loops.  Typically when calling localfilter! with an initializer whose value is a constant but given by an anonymous function or a closure depending on a local variable, the code:\n\nv0 = ... # initial state variable\nlocalfilter!(dst, A, B, ConstantProducer(v0), update, store!)\n\nis much faster than:\n\nv0 = ... # initial state variable\nlocalfilter!(dst, A, B, a -> v0, update, store!)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Utilities","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"LocalFilters.default_start\nLocalFilters.ball","category":"page"},{"location":"reference/#LocalFilters.default_start","page":"Reference","title":"LocalFilters.default_start","text":"default_start(A) -> I::CartesianIndex\n\nyields the initial (multi-dimensional) index of a rectangular region which has the same size as the array A but whose origin (that is, index zero(CartesianIndex{N})) is at the geometrical center of the region (with the same conventions as fftshift.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalFilters.ball","page":"Reference","title":"LocalFilters.ball","text":"LocalFilters.ball(N, r)\n\nyields a boolean mask which is a N-dimensional array with all dimensions odd and equal and set to true where position is inside a N-dimensional ball of radius r.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The LocalFilters package provides local linear and non-linear filters for Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code of LocalFilters is available on GitHub.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"generic.md\", \"neighborhoods.md\", \"linear.md\", \"nonlinear.md\",\n         \"morphology.md\", \"separable.md\", \"reference.md\"]","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"generic/#Generic-local-filters","page":"Generic local filters","title":"Generic local filters","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Most filters provided by the LocalFilters package are implemented by the generic localfilter! method.","category":"page"},{"location":"generic/#The-localfilter!-method","page":"Generic local filters","title":"The localfilter! method","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"A local filtering operation can be performed by calling:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B, initial, update, store!) -> dst","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"where dst is the destination, A is the source, B defines the neighborhood, initial, update, and store! are three functions whose purpose is explained by the following pseudo-code implementing the local filtering:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"@inbounds for i ∈ Sup(A)\n    v = initial(A[i])\n    for j ∈ Sup(A) ∩ (i - Sup(B))\n        v = update(v, A[j], B[i-j])\n    end\n    store!(dst, i, v)\nend","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"where Sup(A) denotes the support of A (that is the set of indices in A) and i - Sup(B) denotes the set of indices j such that i - j ∈ Sup(B) with Sup(B) the support of B.  In other words, j ∈ Sup(A) ∩ (i - Sup(B)) means all indices j such that j ∈ Sup(A) and i - j ∈ Sup(B), hence A[j] and B[i-j] are in-bounds.  Here, indices i and j are multi-dimensional Cartesian indices thus Sup(A) is the analogous of CartesianIndices(A) in Julia.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"The behavior of the filter is fully determined by the neighborhood B (see Section Neighborhoods, structuring elements, and kernels) and by the provided methods used as follows:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"initial(a) yields the initial value of the state variable v given a = A[i];\nupdate(v, a, b) yields the updated state variable v given the state variable v, a = A[j], and b = B[i-j];\nstore!(dst, i, v) extracts the result of the filter from the state variable v and stores it at index i in the destination dst.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"warning: Warning\nThe loop(s) in localfilter! are performed without bounds checking of the destination and it is the caller's responsibility to insure that the destination have the correct size.  It is however always possible to write store! so that it performs bounds checking.","category":"page"},{"location":"generic/#Examples","page":"Generic local filters","title":"Examples","text":"","category":"section"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"For example, implementing a local minimum filter (that is, an erosion), is as simple as:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B,\n             (a)     -> typemax(a),\n             (v,a,b) -> min(v,a),\n             (d,i,v) -> @inbounds(d[i] = v))","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"This is typically how mathematical morphology methods are implemented in LocalFilters.","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"As another example, implementing a convolution by B writes:","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"localfilter!(dst, A, B,\n             (a)     -> zero(a),\n             (v,a,b) -> v + a*b,\n             (d,i,v) -> @inbounds(d[i] = v))","category":"page"},{"location":"generic/","page":"Generic local filters","title":"Generic local filters","text":"Apart from specializations to account for the type of neighborhood defined by B, it is essentially the way the convolve and convolve! methods (described in the Section Linear filters) are implemented in LocalFilters.","category":"page"}]
}
