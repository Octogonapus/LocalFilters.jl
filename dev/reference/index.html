<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · LocalFilters.jl Package</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LocalFilters.jl Package</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../generic/">Generic local filters</a></li><li><a class="tocitem" href="../neighborhoods/">Neighborhoods, structuring elements, and kernels</a></li><li><a class="tocitem" href="../linear/">Linear filters</a></li><li><a class="tocitem" href="../nonlinear/">Non-linear filters</a></li><li><a class="tocitem" href="../morphology/">Non-linear morphological filters</a></li><li><a class="tocitem" href="../separable/">Fast separable filters for associative operations</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Linear-filters"><span>Linear filters</span></a></li><li><a class="tocitem" href="#Mathematical-morphology"><span>Mathematical morphology</span></a></li><li><a class="tocitem" href="#Other-non-linear-filters"><span>Other non-linear filters</span></a></li><li><a class="tocitem" href="#Generic-driver-for-custom-local-filters"><span>Generic driver for custom local filters</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LocalFilters.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>The following summarizes the documentation of types and methods provided by the <code>LocalFilters</code> package.  This information is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#LocalFilters.ConstantProducer"><code>LocalFilters.ConstantProducer</code></a></li><li><a href="#LocalFilters.Kernel"><code>LocalFilters.Kernel</code></a></li><li><a href="#LocalFilters.Neighborhood"><code>LocalFilters.Neighborhood</code></a></li><li><a href="#LocalFilters.RectangularBox"><code>LocalFilters.RectangularBox</code></a></li><li><a href="#LocalFilters.BilateralFilter.bilateralfilter"><code>LocalFilters.BilateralFilter.bilateralfilter</code></a></li><li><a href="#LocalFilters.BilateralFilter.bilateralfilter!"><code>LocalFilters.BilateralFilter.bilateralfilter!</code></a></li><li><a href="#LocalFilters.ball"><code>LocalFilters.ball</code></a></li><li><a href="#LocalFilters.bottom_hat"><code>LocalFilters.bottom_hat</code></a></li><li><a href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a></li><li><a href="#LocalFilters.closing"><code>LocalFilters.closing</code></a></li><li><a href="#LocalFilters.closing!"><code>LocalFilters.closing!</code></a></li><li><a href="#LocalFilters.convolve"><code>LocalFilters.convolve</code></a></li><li><a href="#LocalFilters.convolve!"><code>LocalFilters.convolve!</code></a></li><li><a href="#LocalFilters.default_start"><code>LocalFilters.default_start</code></a></li><li><a href="#LocalFilters.dilate"><code>LocalFilters.dilate</code></a></li><li><a href="#LocalFilters.dilate!"><code>LocalFilters.dilate!</code></a></li><li><a href="#LocalFilters.erode"><code>LocalFilters.erode</code></a></li><li><a href="#LocalFilters.erode!"><code>LocalFilters.erode!</code></a></li><li><a href="#LocalFilters.localextrema"><code>LocalFilters.localextrema</code></a></li><li><a href="#LocalFilters.localextrema!"><code>LocalFilters.localextrema!</code></a></li><li><a href="#LocalFilters.localfilter"><code>LocalFilters.localfilter</code></a></li><li><a href="#LocalFilters.localfilter!"><code>LocalFilters.localfilter!</code></a></li><li><a href="#LocalFilters.localmean"><code>LocalFilters.localmean</code></a></li><li><a href="#LocalFilters.localmean!"><code>LocalFilters.localmean!</code></a></li><li><a href="#LocalFilters.opening"><code>LocalFilters.opening</code></a></li><li><a href="#LocalFilters.opening!"><code>LocalFilters.opening!</code></a></li><li><a href="#LocalFilters.strel"><code>LocalFilters.strel</code></a></li><li><a href="#LocalFilters.top_hat"><code>LocalFilters.top_hat</code></a></li><li><a href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a></li></ul><h2 id="Linear-filters"><a class="docs-heading-anchor" href="#Linear-filters">Linear filters</a><a id="Linear-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-filters" title="Permalink"></a></h2><p><code>LocalFilters</code> provides convolutive filters which are shift-invariant linear filters.</p><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localmean" href="#LocalFilters.localmean"><code>LocalFilters.localmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localmean(A, B=3)</code></pre><p>yields the local mean of <code>A</code> in a neighborhood defined by <code>B</code>.  The result is an array similar to <code>A</code>.  If <code>B</code> is not specified, the neighborhood is a hyperrectangular moving window of size 3 in every dimension.  Otherwise, <code>B</code> may be specified as a Cartesian box, or as an array of booleans of same number of dimensions as <code>A</code>.  If <code>B</code> is a single odd integer (as it is by default), the neighborhood is assumed to be a hyperrectangular moving window of size <code>B</code> in every dimension.</p><p>See also <a href="#LocalFilters.localmean!"><code>localmean!</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/filters.jl#L16-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localmean!" href="#LocalFilters.localmean!"><code>LocalFilters.localmean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localmean!(dst, A, B=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the local mean of <code>A</code> in a neighborhood defined by <code>B</code> and returns <code>dst</code>.</p><p>See also <a href="#LocalFilters.localmean"><code>localmean</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/filters.jl#L42-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.convolve" href="#LocalFilters.convolve"><code>LocalFilters.convolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolve(A, B)</code></pre><p>yields the discrete convolution of array <code>A</code> by the kernel defined by <code>B</code>.  The result <code>dst</code> is an array similar to <code>A</code>.</p><p>Using <code>Sup(A)</code> to denote the set of valid indices for array <code>A</code> and assuming <code>B</code> is an array of values, the discrete convolution of <code>A</code> by <code>B</code> writes:</p><pre><code class="nohighlight hljs">T = promote_type(eltype(A), eltype(B))
for i ∈ Sup(A)
    v = zero(T)
    @inbounds for k ∈ Sup(B) ∩ (i - Sup(A))
        v += A[i-k]*B[k]
    end
    dst[i] = v
end</code></pre><p>with <code>T</code> the type of the product of elements of <code>A</code> and <code>B</code>, and where <code>Sup(B) ∩ (i - Sup(A))</code> denotes the subset of indices <code>k</code> such that <code>k ∈ Sup(B)</code> and <code>i - k ∈ Sup(A)</code> and thus for which <code>B[k]</code> and <code>A[i-k]</code> are valid.</p><p>See also <a href="#LocalFilters.convolve!"><code>convolve!</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/filters.jl#L122-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.convolve!" href="#LocalFilters.convolve!"><code>LocalFilters.convolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convolve!(dst, A, B) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the discrete convolution of <code>A</code> by the kernel <code>B</code> and returns <code>dst</code>.</p><p>See also <a href="#LocalFilters.convolve"><code>convolve</code></a> and <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/filters.jl#L159-L167">source</a></section></article><h2 id="Mathematical-morphology"><a class="docs-heading-anchor" href="#Mathematical-morphology">Mathematical morphology</a><a id="Mathematical-morphology-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-morphology" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.erode" href="#LocalFilters.erode"><code>LocalFilters.erode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode(A, R=3) -&gt; Amin</code></pre><p>yields the erosion of <code>A</code> by the structuring element defined by <code>R</code>.  The erosion is the array of local minima of <code>A</code>.  The returned result <code>Amin</code> is similar to <code>A</code> (same size and type).</p><p>If the structuring element <code>R</code> is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used.  If specified as an odd integer (as is assumed by default), the structuring element is a hyperrectangular moving window of size <code>R</code> along every dimension of <code>A</code>.</p><p>An erosion is one of the most basic operations of mathematical morphology.  See <a href="#LocalFilters.erode!"><code>erode!</code></a> for an in-place version of the method, <a href="#LocalFilters.dilate"><code>dilate</code></a> for retrieving the local maxima, and <a href="#LocalFilters.localextrema"><code>localextrema</code></a> for performing an erosion and a dilation in a single pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.erode!" href="#LocalFilters.erode!"><code>LocalFilters.erode!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">erode!(Amin, A, R=3) -&gt; Amin</code></pre><p>overwrites <code>Amin</code> with the erosion of the array <code>A</code> by the structuring element defined by <code>R</code> and returns <code>Amin</code>.</p><p>If the structuring element <code>R</code> is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place.  That is, <code>A</code> and <code>Amin</code> can be the same arrays.  In that case, the following syntax is allowed:</p><pre><code class="nohighlight hljs">erode!(A, R=3) -&gt; A</code></pre><p>See <a href="#LocalFilters.erode"><code>erode</code></a> for an out-of-place version and for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L34-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.dilate" href="#LocalFilters.dilate"><code>LocalFilters.dilate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dilate(A, R=3) -&gt; Amax</code></pre><p>yields the dilation of <code>A</code> by the structuring element defined by <code>R</code>.  The dilation is the array of local maxima of <code>A</code>.  The returned result <code>Amax</code> is similar to <code>A</code> (same size and type).</p><p>If the structuring element <code>R</code> is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used.  If specified as an odd integer (as is assumed by default), the structuring element is a hyperrectangular moving window of size <code>R</code> along every dimension of <code>A</code>.</p><p>A dilation is one of the most basic operations of mathematical morphology.  See <a href="#LocalFilters.dilate!"><code>dilate!</code></a> for an in-place version of the method, <a href="#LocalFilters.erode"><code>erode</code></a> for retrieving the local minima, and <a href="#LocalFilters.localextrema"><code>localextrema</code></a> for performing an erosion and a dilation in a single pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L95-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.dilate!" href="#LocalFilters.dilate!"><code>LocalFilters.dilate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dilate!(Amax, A, R=3) -&gt; Amax</code></pre><p>overwrites <code>Amax</code> with a dilation of the array <code>A</code> by the structuring element defined by <code>R</code> and returns <code>Amax</code>.</p><p>If the structuring element <code>R</code> is a simple hyperrectangular moving window, the much faster van Herk-Gil-Werman algorithm is used and the operation can be done in-place.  That is, <code>A</code> and <code>Amin</code> can be the same arrays.  In that case, the following syntax is allowed:</p><pre><code class="nohighlight hljs">dilate!(A, R=3) -&gt; A</code></pre><p>See <a href="#LocalFilters.dilate"><code>dilate</code></a> for an out-of-place version and for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L115-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localextrema" href="#LocalFilters.localextrema"><code>LocalFilters.localextrema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localextrema(A, R=3) -&gt; Amin, Amax</code></pre><p>yields the results of performing an erosion and a dilation of <code>A</code> by the structuring element defined by <code>R</code> in a single pass.  Calling this method is usually almost twice as fast as calling <a href="#LocalFilters.erode"><code>erode</code></a> and <a href="#LocalFilters.dilate"><code>dilate</code></a>.</p><p>See <a href="#LocalFilters.localextrema!"><code>localextrema!</code></a> for an in-place version of the method, and <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for a description of these operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localextrema!" href="#LocalFilters.localextrema!"><code>LocalFilters.localextrema!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localextrema!(Amin, Amax, A, R=3) -&gt; Amin, Amax</code></pre><p>overwrites <code>Amin</code> and <code>Amax</code> with, respectively, an erosion and a dilation of the array <code>A</code> by the structuring element defined by <code>R</code> in a single pass.</p><p>See <a href="#LocalFilters.localextrema"><code>localextrema</code></a> for an out-of-place version for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L190-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.closing" href="#LocalFilters.closing"><code>LocalFilters.closing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closing(A, R=3) -&gt; dst</code></pre><p>yields a closing of array <code>A</code> by the structuring element defined by <code>R</code>.  A closing is a dilation followed by an erosion.  The result <code>dst</code> is an array similar to <code>A</code>.</p><p>See <a href="#LocalFilters.closing!"><code>closing!</code></a> for an in-place version of the method, <a href="#LocalFilters.opening"><code>opening</code></a> for a related filter, and <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for a description of these operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L248-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.closing!" href="#LocalFilters.closing!"><code>LocalFilters.closing!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closing!(dst, wrk, A, R=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of a closing of <code>A</code> by the structuring element defined by <code>R</code> using <code>wrk</code> as a workspace array.  The arguments <code>dst</code>, <code>wrk</code>, and <code>A</code> must be similar arrays, <code>dst</code> and <code>A</code> may be identical, but <code>wrk</code> must not be the same array as <code>A</code> or <code>dst</code>.  The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.closing"><code>closing</code></a> for a description of this kind of filter and for the meaning of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L263-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.opening" href="#LocalFilters.opening"><code>LocalFilters.opening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opening(A, R=3) -&gt; dst</code></pre><p>yields an opening of array <code>A</code> by the structuring element defined by <code>R</code>.  An opening is an erosion followed by a dilation.  The result <code>dst</code> is an array similar to <code>A</code>.</p><p>See <a href="#LocalFilters.opening!"><code>opening!</code></a> for an in-place version of the method, <a href="#LocalFilters.closing"><code>closing</code></a> for a related filter, and <a href="#LocalFilters.erode"><code>erode</code></a> or <a href="#LocalFilters.dilate"><code>dilate</code></a> for a description of these operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L288-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.opening!" href="#LocalFilters.opening!"><code>LocalFilters.opening!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opening!(dst, wrk, A, R=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of an opening of <code>A</code> by the structuring element defined by <code>R</code> using <code>wrk</code> as a workspace array.  The arguments <code>dst</code>, <code>wrk</code>, and <code>A</code> must be similar arrays, <code>dst</code> and <code>A</code> may be identical, but <code>wrk</code> must not be the same array as <code>A</code> or <code>dst</code>.  The destination <code>dst</code> is returned.</p><p>See <a href="#LocalFilters.opening"><code>opening</code></a> for a description of this kind of filter and for the meaning of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L303-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.top_hat" href="#LocalFilters.top_hat"><code>LocalFilters.top_hat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">top_hat(A, R=3 [, S]) -&gt; dst</code></pre><p>performs a <em>summit detection</em> by applying a top-hat filter to array <code>A</code> using the structuring element defined by <code>R</code> for the feature detection.  Top-hat filtering is equivalent to:</p><pre><code class="nohighlight hljs">dst = A .- opening(A, R)</code></pre><p>Optional argument <code>S</code> specifies the structuring element for smoothing <code>A</code> prior to top-hat filtering.  If <code>R</code> and <code>S</code> are specified as the radii of the structuring elements, then <code>S</code> should be smaller than <code>R</code>.  For instance:</p><pre><code class="nohighlight hljs">top_hat(bitmap, 3, 1)</code></pre><p>may be used to detect text or lines in a bitmap image.</p><p>See <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a> for a related operation, <a href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a> for an in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L332-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.top_hat!" href="#LocalFilters.top_hat!"><code>LocalFilters.top_hat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LocalFilters.top_hat!(dst, wrk, A, R=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of a top-hat filter applied to <code>A</code> with structuring element <code>R</code>, and using <code>wrk</code> as a workspace whose contents is not preserved.  The arguments <code>A</code>, <code>dst</code>, and <code>wrk</code> must be similar but different arrays.  The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.top_hat"><code>top_hat</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L360-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.bottom_hat" href="#LocalFilters.bottom_hat"><code>LocalFilters.bottom_hat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bottom_hat(A, R=3 [, S]) -&gt; dst</code></pre><p>performs a <em>valley detection</em> by applying a bottom-hat filter to array <code>A</code> using the structuring element defined by <code>R</code> for the feature detection. Bottom-hat filtering is equivalent to:</p><pre><code class="nohighlight hljs">dst = closing(A, R) .- A</code></pre><p>Optional argument <code>S</code> specifies the structuring element for smoothing <code>A</code> prior to bottom-hat filtering.  If <code>R</code> and <code>S</code> are specified as the radii of the structuring elements, then <code>S</code> should be smaller than <code>R</code>.</p><p>See <a href="#LocalFilters.top_hat"><code>top_hat</code></a> for a related operation, <a href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a> for an in-place version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L381-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.bottom_hat!" href="#LocalFilters.bottom_hat!"><code>LocalFilters.bottom_hat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LocalFilters.bottom_hat!(dst, wrk, A, R=3) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of a bottom-hat filter applied to <code>A</code> with structuring element <code>R</code> and optional smoothing element <code>S</code>.  Argument <code>wrk</code> is a workspace array whose contents is not preserved.  The arguments <code>A</code>, <code>dst</code>, and <code>wrk</code> must be similar but different arrays.  The destination <code>dst</code> is returned.</p><p>See also <a href="#LocalFilters.bottom_hat"><code>bottom_hat</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/morphology.jl#L405-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.strel" href="#LocalFilters.strel"><code>LocalFilters.strel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strel(T, A)</code></pre><p>yields a <em>structuring element</em> suitable for mathematical morphology operations. The result is a <code>Kernel</code> whose elements have type <code>T</code> (which can be <code>Bool</code> or a floating-point type).  Argument <code>A</code> can be a Cartesian box or a <code>Kernel</code> with boolean elements.</p><p>If <code>T</code> is a floating-point type, then the result is a so-called <em>flat</em> structuring element whose coefficients are <code>zero(T)</code> inside the shape defined by <code>A</code> and <code>-T(Inf)</code> elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/basics.jl#L462-L474">source</a></section></article><h2 id="Other-non-linear-filters"><a class="docs-heading-anchor" href="#Other-non-linear-filters">Other non-linear filters</a><a id="Other-non-linear-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Other-non-linear-filters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.BilateralFilter.bilateralfilter" href="#LocalFilters.BilateralFilter.bilateralfilter"><code>LocalFilters.BilateralFilter.bilateralfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bilateralfilter([T=float(eltype(A)),] A, F, G, ...)</code></pre><p>yields the result of applying the bilateral filter on array <code>A</code>.</p><p>Argument <code>F</code> specifies how to smooth the differences in values.  It may be function which takes two values from <code>A</code> as arguments and returns a nonnegative weight.  It may be a real which is assumed to be the standard deviation of a Gaussian.</p><p>Arguments <code>G, ...</code> specify the settings of the distance filter for smoothing differences in coordinates.  There are several possibilities:</p><ul><li><p><code>G, ...</code> can be a <a href="#LocalFilters.Kernel"><code>LocalFilters.Kernel</code></a> instance (specified as a single argument).</p></li><li><p>Argument <code>G</code> may be a function taking as argument the Cartesian index of the coordinate differences and returning a nonnegative weight.  Argument <code>G</code> may also be a real specifying the standard deviation of the Gaussian used to compute weights.  Subsequent arguments <code>...</code> are to specify the neighborhood where to apply the distance filter function, they can be a <a href="#LocalFilters.Neighborhood"><code>Neighborhood</code></a> object such as a <a href="#LocalFilters.RectangularBox"><code>RectangularBox</code></a> or anything that may defined a neighborhood such as an odd integer assumed to be the width of the neighborhood along every dimensions of <code>A</code>.  If a standard deviation <code>σ</code> is specified for <code>G</code> with no subsequent arguments, a default window of size <code>±3σ</code> is assumed.</p></li></ul><p>Optional argument <code>T</code> can be used to force the element type used for (most) computations.  This argument is needed if the element type of <code>A</code> is not a real.</p><p>See <a href="#LocalFilters.BilateralFilter.bilateralfilter!"><code>bilateralfilter!</code></a> for an in-place version of this function and see <a href="https://en.wikipedia.org/wiki/Bilateral_filter">Wikipedia</a> for a description of the bilateral filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/bilateral.jl#L48-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.BilateralFilter.bilateralfilter!" href="#LocalFilters.BilateralFilter.bilateralfilter!"><code>LocalFilters.BilateralFilter.bilateralfilter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bilateralfilter!([T=float(eltype(A)),] dst, A, F, G, ...) -&gt; dst</code></pre><p>overwrites <code>dst</code> with the result of applying the bilateral filter on array <code>A</code> and returns <code>dst</code>.</p><p>See <a href="#LocalFilters.BilateralFilter.bilateralfilter"><code>bilateralfilter</code></a> for a description of the other arguments than <code>dst</code> and see <a href="https://en.wikipedia.org/wiki/Bilateral_filter">Wikipedia</a> for a description of the bilateral filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/bilateral.jl#L91-L101">source</a></section></article><h2 id="Generic-driver-for-custom-local-filters"><a class="docs-heading-anchor" href="#Generic-driver-for-custom-local-filters">Generic driver for custom local filters</a><a id="Generic-driver-for-custom-local-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-driver-for-custom-local-filters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localfilter" href="#LocalFilters.localfilter"><code>LocalFilters.localfilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localfilter([T=eltype(A),] A, dims, op, rngs[, wrk]) -&gt; dst</code></pre><p>yields the result of applying van Herk-Gil-Werman algorithm to filter array <code>A</code> along dimension(s) <code>dims</code> with (associative) binary operation <code>op</code> and contiguous structuring element(s) defined by the interval(s) <code>rngs</code>.  Optional argument <code>wrk</code> is a workspace array which is automatically allocated if not provided; otherwise, it must be a vector with the same element type as <code>A</code> and it is resized as needed (by calling the <code>resize!</code> method).  The optional argument <code>T</code> allows to specify another type of element than <code>eltype(A)</code> for the result.</p><p>Argument <code>dims</code> specifies along which dimension(s) of <code>A</code> the filter is to be applied, it can be a single integer, a tuple of integers, or a colon <code>:</code> to apply the operation to all dimensions.  Dimensions are processed in the order given by <code>dims</code> (the same dimension may appear several times) and there must be a matching interval in <code>rngs</code> to specify the structuring element (except that if <code>rngs</code> is a single interval, it is used for every dimension in <code>dims</code>).  An interval is either an integer or an integer valued unit range in the form <code>kmin:kmax</code> (an interval specified as a single integer, say <code>k</code>, is the same as specifying <code>k:k</code>).</p><p>Assuming a mono-dimensional array <code>A</code>, the single filtering pass:</p><pre><code class="nohighlight hljs">dst = localfilter(A, :, op, rng)</code></pre><p>amount to computing:</p><pre><code class="nohighlight hljs">dst[j] = A[j-kmax] ⋄ A[j-kmax+1] ⋄ A[j-kmax+2] ⋄ ... ⋄ A[j-kmin]</code></pre><p>for all <code>j ∈ [first(axes(A,1)):last(axes(A,1))]</code>, with <code>x ⋄ y = op(x, y)</code>, <code>kmin = first(rng)</code> and <code>kmax = last(rng)</code>.  Note that if <code>kmin = kmax = k</code> (which occurs if <code>rng</code> is a simple integer), the result of the filter is to operate a simple shift by <code>k</code> along the corresponding dimension and has no effects if <code>k = 0</code>.  This can be exploited to not filter some dimension(s).</p><p>The <em>morphological erosion</em> (local minimum) of the array <code>A</code> on a centered structuring element of width 7 in every dimension can be obtained by:</p><pre><code class="nohighlight hljs">localfilter(A, :, min, -3:3)</code></pre><p>Index interval <code>0:0</code> may be specified to do nothing along the corresponding dimension.  For instance, assuming <code>A</code> is a three-dimensional array:</p><pre><code class="nohighlight hljs">localfilter(A, :, max, (-3:3, 0:0, -4:4))</code></pre><p>yields the <em>morphological dilation</em> (<em>i.e.</em> local maximum) of <code>A</code> in a centered local neighborhood of size <code>7×1×9</code> (nothing is done along the second dimension).  The same result may be obtained with:</p><pre><code class="nohighlight hljs">localfilter(A, (1,3), max, (-3:3, -4:4))</code></pre><p>where the second dimension is omitted from the list of dimensions.</p><p>The <em>local average</em> of the two-dimensional array <code>A</code> on a centered moving window of size 11×11 can be computed as:</p><pre><code class="nohighlight hljs">localfilter(A, :, +, (-5:5, -5:5))*(1/11)</code></pre><p>See <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a> for an in-place version of the method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/separable.jl#L32-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.localfilter!" href="#LocalFilters.localfilter!"><code>LocalFilters.localfilter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">localfilter!([dst = A,] A, dims, op, rngs[, wrk])</code></pre><p>overwrites the contents of <code>dst</code> with the result of applying van Herk-Gil-Werman algorithm to filter array <code>A</code> along dimension(s) <code>dims</code> with (associative) binary operation <code>op</code> and contiguous structuring element(s) defined by the interval(s) <code>rngs</code> and using optional argument <code>wrk</code> as a workspace array.  The destination <code>dst</code> must have the same indices as the source <code>A</code> (that is, <code>axes(dst) == axes(A)</code>).  Operation may be done in-place and <code>dst</code> and <code>A</code> can be the same; this is the default behavior if <code>dst</code> is not specified.</p><p>See <a href="#LocalFilters.localfilter"><code>localfilter</code></a> for a full description of the method.</p><p>The in-place <em>morphological erosion</em> (local minimum) of the array <code>A</code> on a centered structuring element of width 7 in every dimension can be obtained by:</p><pre><code class="nohighlight hljs">localfilter!(A, :, min, -3:3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/separable.jl#L109-L128">source</a></section><section><div><pre><code class="nohighlight hljs">localfilter!(dst, A, B, initial, update, store!) -&gt; dst</code></pre><p>overwrites the destination <code>dst</code> with the result of a local filter applied to the source <code>A</code>, on a relative neighborhood defined by <code>B</code>, and implemented by the functions <code>initial</code>, <code>update</code>, and <code>store!</code>.  The purpose of these functions is explained by the following pseudo-code implementing the local fitering:</p><pre><code class="nohighlight hljs">@inbounds for i ∈ Sup(A)
    v = initial(A[i])
    for j ∈ Sup(A) ∩ (i - Sup(B))
        v = update(v, A[j], B[i-j])
    end
    store!(dst, i, v)
end</code></pre><p>where <code>Sup(A)</code> denotes the support of <code>A</code> (that is the set of indices in <code>A</code>) and <code>i - Sup(B)</code> denotes the set of indices <code>j</code> such that <code>i - j ∈ Sup(B)</code> with <code>Sup(B)</code> the support of <code>B</code>.  In other words, <code>j ∈ Sup(A) ∩ (i - Sup(B))</code> means all indices <code>j</code> such that <code>j ∈ Sup(A)</code> and <code>i - j ∈ Sup(B)</code> so that <code>A[j]</code> and <code>B[i-j]</code> are in-bounds.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The loop(s) in <code>localfilter!</code> are performed without bounds checking of the destination and it is the caller&#39;s responsibility to insure that the destination have the correct size.  It is however always possible to write <code>store!</code> so that it performs bounds checking.</p></div></div><p>For example, implementing a local minimum filter (that is, an <em>erosion</em>), is as simple as:</p><pre><code class="nohighlight hljs">localfilter!(dst, A, B,
             (a)     -&gt; typemax(a),
             (v,a,b) -&gt; min(v,a),
             (d,i,v) -&gt; @inbounds(d[i] = v))</code></pre><p>As another example, implementing a convolution by <code>B</code> writes:</p><pre><code class="nohighlight hljs">localfilter!(dst, A, B,
             (a)     -&gt; zero(a),
             (v,a,b) -&gt; v + a*b,
             (d,i,v) -&gt; @inbounds(d[i] = v))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the methods <code>init</code>, <code>update</code>, and/or <code>store!</code> are anonymous functions or closures, beware that they should not depend on local variables because this may have a strong impact on performances.  For instance, you may consider using <a href="#LocalFilters.ConstantProducer"><code>LocalFilters.ConstantProducer</code></a> as a replacement for <code>init</code> (have a look at the implementation of methods such as <a href="#LocalFilters.localmean!"><code>localmean!</code></a> or <a href="#LocalFilters.convolve!"><code>convolve!</code></a>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/filters.jl#L212-L263">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.Neighborhood" href="#LocalFilters.Neighborhood"><code>LocalFilters.Neighborhood</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Neighborhood</code></pre><p>is the abstract type of which all neighborhood types inherit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/types.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.RectangularBox" href="#LocalFilters.RectangularBox"><code>LocalFilters.RectangularBox</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RectangularBox(start, stop)</code></pre><p>yields a neighborhood which is a rectangular (Cartesian) box defined by the bounds of the multi-dimensional indices in the box.</p><p>Another possibility is to specify the dimensions of the box and the offsets of its central element:</p><pre><code class="nohighlight hljs">RectangularBox(dims, offs)</code></pre><p>with <code>dims</code> a <code>N</code>-tuple of dimensions and <code>offs</code> either a <code>N</code>-tuple of indices of an instance of <code>CartesianIndex{N}</code>.</p><p>A <code>RectangularBox</code> can also be defined by the index ranges along all the dimensions.  For example:</p><pre><code class="nohighlight hljs">RectangularBox(-3:3, 0, -2:1)
RectangularBox((-3:3, 0, -2:1))</code></pre><p>both yield a 3-dimensional <code>RectangularBox</code> of size <code>7×1×4</code> and whose first index varies on <code>-3:3</code>, its second index is <code>0</code> while its third index varies on <code>-2:1</code>.</p><p>Finally, a <code>RectangularBox</code> can be defined as:</p><pre><code class="nohighlight hljs">RectangularBox(R)</code></pre><p>where <code>R</code> is an instance of <code>CartesianIndices</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/types.jl#L22-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.Kernel" href="#LocalFilters.Kernel"><code>LocalFilters.Kernel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Kernel</code> can be used to define a weighted neighborhood (for weighted local average or for convolution) or a structuring element (for mathematical morphology).  It is a rectangular array of coefficients over a, possibly off-centered, rectangular neighborhood.  In general, it is sufficient to specify <code>::Kernel{T,N}</code> in the signature of methods, with <code>T</code> the type of the coefficients and <code>N</code> the number of dimensions (the third parameter <code>A</code> of the type is to fully qualify the type of the array of coefficients).</p><p>A kernel is built as:</p><pre><code class="nohighlight hljs">B = Kernel{T}(C, start=default_start(C))</code></pre><p>where <code>C</code> is the array of coefficients (which can be retrieved by <code>coefs(B)</code>) and <code>start</code> the initial <code>CartesianIndex</code> for indexing the kernel (which can be retrieved by <code>first_cartesian_index(B)</code>).  The <code>start</code> parameter let the caller choose an arbitrary origin for the kernel coefficients; when a filter is applied, the following mapping is assumed:</p><pre><code class="nohighlight hljs">B[k] ≡ C[k + off]</code></pre><p>where <code>off = first_cartesian_index(C) - first_cartesian_index(B)</code>.</p><p>If <code>start</code> is omitted, its value is set so that the <em>origin</em> (whose index is <code>zero(CartesianIndex{N})</code> with <code>N</code> the number of dimensions) of the kernel indices is at the geometric center of the array of coefficients (see <a href="#LocalFilters.default_start"><code>LocalFilters.default_start</code></a>).  Optional type parameter <code>T</code> is to impose the type of the coefficients.</p><p>To convert the element type of the coefficients of an existing kernel, do:</p><pre><code class="nohighlight hljs">Kernel{T}(K)</code></pre><p>which yields a kernel whose coefficients are those of the kernel <code>K</code> converted to type <code>T</code>.</p><p>It is also possible to convert instances of <a href="#LocalFilters.RectangularBox"><code>RectangularBox</code></a> into a kernel with boolean coefficients by calling:</p><pre><code class="nohighlight hljs">Kernel(B)</code></pre><p>where <code>B</code> is the neighborhood to convert into an instance of <code>Kernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/types.jl#L60-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.ConstantProducer" href="#LocalFilters.ConstantProducer"><code>LocalFilters.ConstantProducer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantProducer(val)</code></pre><p>yields a functor object which, when called as a function with any number of arguments of any types, always yields the value <code>val</code>.</p><p>This is useful to avoid closures which are quite inefficient and thus have a strong impact on performances when called repeatedly in loops.  Typically when calling <a href="#LocalFilters.localfilter!"><code>localfilter!</code></a> with an initializer whose value is a constant but given by an anonymous function or a closure depending on a local variable, the code:</p><pre><code class="nohighlight hljs">v0 = ... # initial state variable
localfilter!(dst, A, B, ConstantProducer(v0), update, store!)</code></pre><p>is much faster than:</p><pre><code class="nohighlight hljs">v0 = ... # initial state variable
localfilter!(dst, A, B, a -&gt; v0, update, store!)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/types.jl#L191-L211">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.default_start" href="#LocalFilters.default_start"><code>LocalFilters.default_start</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_start(A) -&gt; I::CartesianIndex</code></pre><p>yields the initial (multi-dimensional) index of a rectangular region which has the same size as the array <code>A</code> but whose origin (that is, index <code>zero(CartesianIndex{N})</code>) is at the geometrical center of the region (with the same conventions as <code>fftshift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/basics.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LocalFilters.ball" href="#LocalFilters.ball"><code>LocalFilters.ball</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LocalFilters.ball(N, r)</code></pre><p>yields a boolean mask which is a <code>N</code>-dimensional array with all dimensions odd and equal and set to true where position is inside a <code>N</code>-dimensional ball of radius <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LocalFilters.jl/blob/06cc17e15e2fb2acf42c14198f6766c38b42a9b6/src/basics.jl#L548-L555">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../separable/">« Fast separable filters for associative operations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 13 June 2022 07:11">Monday 13 June 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
